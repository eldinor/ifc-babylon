import{bp as N,f$ as ke,aX as z,p as v,zl as xe,iU as re,th as le,xe as _e,cq as b,op as Ue,bt as Be,oj as J,bF as ie,bw as Z,bC as K,bz as P,cL as ue,V as O,bx as W,b4 as A,bE as Ne,ap as Q,qL as k,cy as ee,bD as se,qm as De,cI as We,dC as G,rn as oe,cK as ae,bn as Le,bP as Ke,l as Ae,c7 as Pe,cY as ze,cO as qe,dX as $e,qu as Ge,oD as He}from"./index-Ds31uFJL.js";import{M as we,a as ye,b as H,C as Y,S as je}from"./textureMerger-DTwggJe8.js";const L=1e-6,j=new z(.04,.04,.04),Ye=1024,ce=z.White(),Te=z.BlackReadOnly;function be(a){switch(a){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif";case"image/ktx2":return".ktx2"}}function Oe(a){switch(a){case"image/jpeg":case"image/png":case"image/webp":case"image/avif":case"image/ktx2":return!0;default:return!1}}async function Qe(a){const e=a.getInternalTexture();if(!e||e.source!==1||e.invertY)return null;const t=e._buffer;let s,n=a.mimeType;try{t?ArrayBuffer.isView(t)?s=t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength):t instanceof ArrayBuffer?s=t:t instanceof Blob?(s=await t.arrayBuffer(),n=t.type||n):typeof t=="string"?(s=await N.LoadFileAsync(t),n=J(t)||n):typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement&&(s=await N.LoadFileAsync(t.src),n=J(t.src)||n):(s=await N.LoadFileAsync(e.url),n=J(e.url)||n)}catch{return null}return s&&Oe(n)?new Blob([s],{type:n}):null}function Xe(a,e,t){if(e<j.r)return 0;const s=j.r,n=a*t/(1-j.r)+e-2*j.r,i=j.r-e,r=n*n-4*s*i;return _e.Clamp((-n+Math.sqrt(r))/(2*s),0,1)}function Ze(a){const e=a.diffuseColor.toLinearSpace(a.getScene().getEngine().useExactSrgbConversions).scale(.5),t=a.alpha,s=_e.Clamp(a.specularPower,0,Ye),n=je(s);return{baseColorFactor:[e.r,e.g,e.b,t],metallicFactor:0,roughnessFactor:n}}function Ee(a,e){e.needAlphaBlending()?a.alphaMode="BLEND":e.needAlphaTesting()&&(a.alphaMode="MASK",a.alphaCutoff=e.alphaCutOff)}function Me(a,e,t){const s=new Uint8Array(a*e*4);for(let i=0;i<s.length;i=i+4)s[i]=s[i+1]=s[i+2]=s[i+3]=255;return Be.CreateRGBATexture(s,a,e,t)}function Ce(a){if(a instanceof Uint8Array){const e=a.length,t=new Float32Array(a.length);for(let s=0;s<e;++s)t[s]=a[s]/255;return t}else{if(a instanceof Float32Array)return a;throw new Error("Unsupported pixel format!")}}class Je{constructor(e){this._exporter=e,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(e){return e?this._textureMap.get(e.uniqueId)??null:null}async exportStandardMaterialAsync(e,t){const s=Ze(e),n={name:e.name};if(e.backFaceCulling!=null&&!e.backFaceCulling&&(e.twoSidedLighting||N.Warn(e.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),t){const r=[],o=e.diffuseTexture;o&&r.push(this.exportTextureAsync(o).then(u=>{u&&(s.baseColorTexture=u)}));const c=e.bumpTexture;c&&r.push(this.exportTextureAsync(c).then(u=>{u&&(n.normalTexture=u,c.level!==1&&(n.normalTexture.scale=c.level))}));const l=e.emissiveTexture;l&&(n.emissiveFactor=[1,1,1],r.push(this.exportTextureAsync(l).then(u=>{u&&(n.emissiveTexture=u)})));const f=e.ambientTexture;f&&r.push(this.exportTextureAsync(f).then(u=>{if(u){const h={index:u.index};n.occlusionTexture=h}})),r.length>0&&(this._exporter._materialNeedsUVsSet.add(e),await Promise.all(r))}(e.alpha<1||e.opacityTexture)&&(e.alphaMode===ke.ALPHA_COMBINE?n.alphaMode="BLEND":N.Warn(e.name+": glTF 2.0 does not support alpha mode: "+e.alphaMode.toString())),e.emissiveColor&&!e.emissiveColor.equalsWithEpsilon(Te,L)&&(n.emissiveFactor=e.emissiveColor.asArray()),n.pbrMetallicRoughness=s,Ee(n,e),await this._finishMaterialAsync(n,e);const i=this._exporter._materials;return i.push(n),i.length-1}async _finishMaterialAsync(e,t){const s=await this._exporter._extensionsPostExportMaterialAdditionalTexturesAsync("exportMaterial",e,t),n=[];for(const i of s)n.push(this.exportTextureAsync(i));await Promise.all(n),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",e,t)}_resizeTexturesToSameDimensions(e,t,s){const n=e?e.getSize():{width:0,height:0},i=t?t.getSize():{width:0,height:0};let r,o;return n.width<i.width?(e&&e instanceof v?r=xe.CreateResizedCopy(e,i.width,i.height,!0):r=Me(i.width,i.height,s),o=t):n.width>i.width?(t&&t instanceof v?o=xe.CreateResizedCopy(t,n.width,n.height,!0):o=Me(n.width,n.height,s),r=e):(r=e,o=t),{texture1:r,texture2:o}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(e,t,s){const n=new Array;if(!(e||t))return await Promise.reject("diffuse and specular glossiness textures are not defined!");const i=e?e.getScene():t?t.getScene():null;if(i){const r=this._resizeTexturesToSameDimensions(e,t,i),o=r.texture1?.getSize();let c,l;const f=o.width,u=o.height,h=await r.texture1.readPixels(),m=await r.texture2.readPixels();if(h)c=Ce(h);else return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(m)l=Ce(m);else return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");const _=l.byteLength,g=new Uint8Array(_),p=new Uint8Array(_),d=4,w=new z(0,0,0);let y=0,x=0;for(let I=0;I<u;++I)for(let M=0;M<f;++M){const T=(f*I+M)*d,U=new z(c[T],c[T+1],c[T+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(s.diffuseColor),B=new z(l[T],l[T+1],l[T+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(s.specularColor),F=l[T+3]*s.glossiness,q={diffuseColor:U,specularColor:B,glossiness:F},D=this._convertSpecularGlossinessToMetallicRoughness(q);w.r=Math.max(w.r,D.baseColor.r),w.g=Math.max(w.g,D.baseColor.g),w.b=Math.max(w.b,D.baseColor.b),y=Math.max(y,D.metallic),x=Math.max(x,D.roughness),p[T]=D.baseColor.r*255,p[T+1]=D.baseColor.g*255,p[T+2]=D.baseColor.b*255,p[T+3]=r.texture1.hasAlpha?c[T+3]*255:255,g[T]=0,g[T+1]=D.roughness*255,g[T+2]=D.metallic*255,g[T+3]=255}const E={baseColor:w,metallic:y,roughness:x};let C=!1,S=!1;for(let I=0;I<u;++I)for(let M=0;M<f;++M){const T=(f*I+M)*d;p[T]/=E.baseColor.r>L?E.baseColor.r:1,p[T+1]/=E.baseColor.g>L?E.baseColor.g:1,p[T+2]/=E.baseColor.b>L?E.baseColor.b:1;const B=z.FromInts(p[T],p[T+1],p[T+2]).toGammaSpace(i.getEngine().useExactSrgbConversions);p[T]=B.r*255,p[T+1]=B.g*255,p[T+2]=B.b*255,B.equalsWithEpsilon(ce,L)||(S=!0),g[T+1]/=E.roughness>L?E.roughness:1,g[T+2]/=E.metallic>L?E.metallic:1,z.FromInts(255,g[T+1],g[T+2]).equalsWithEpsilon(ce,L)||(C=!0)}return C&&n.push(re(g,f,u).then(I=>{E.metallicRoughnessTextureData=I})),S&&n.push(re(p,f,u).then(I=>{E.baseColorTextureData=I})),await Promise.all(n).then(()=>E)}else return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(e){const t=this._getPerceivedBrightness(e.diffuseColor),s=this._getPerceivedBrightness(e.specularColor),n=1-this._getMaxComponent(e.specularColor),i=Xe(t,s,n),r=e.diffuseColor.scale(n/(1-j.r)/Math.max(1-i,L)),o=e.specularColor.subtract(j.scale(1-i)).scale(1/Math.max(i,L));let c=z.Lerp(r,o,i*i);return c=c.clampToRef(0,1,c),{baseColor:c,metallic:i,roughness:1-e.glossiness}}_getPerceivedBrightness(e){return Math.sqrt(.299*e.r*e.r+.587*e.g*e.g+.114*e.b*e.b)}_getMaxComponent(e){return Math.max(e.r,Math.max(e.g,e.b))}async _convertMetalRoughFactorsToMetallicRoughnessAsync(e,t,s,n,i,r,o,c,l){const f=[],u={baseColor:e,metallic:t,roughness:s};if(l)if(o instanceof le){if(o.geometryOpacityTexture){const h=n&&n.getInternalTexture()?n.getInternalTexture().uniqueId:0,m=o.geometryOpacityTexture&&o.geometryOpacityTexture.getInternalTexture()?o.geometryOpacityTexture.getInternalTexture().uniqueId:0,_=+`${h}${m}`,g=this._textureMap.get(_);g?c.baseColorTexture=g:f.push(we("baseColorOpacityTexture",ye(n?H(n,0):Y(1),n?H(n,1):Y(1),n?H(n,2):Y(1),H(o.geometryOpacityTexture,0)),o.getScene()).then(async p=>{const d=await this.exportTextureAsync(p,_);d&&(c.baseColorTexture=d)}))}else n&&f.push(this.exportTextureAsync(n).then(h=>{h&&(c.baseColorTexture=h)}));if(o._useMetallicFromMetallicTextureBlue&&i)f.push(this.exportTextureAsync(i).then(h=>{h&&(c.metallicRoughnessTexture=h)}));else if(r||i){const h=i&&i.getInternalTexture()?i.getInternalTexture().uniqueId:0,m=r&&r.getInternalTexture()?r.getInternalTexture().uniqueId:0,_=+`${h}${m}`,g=this._textureMap.get(_);g?c.metallicRoughnessTexture=g:f.push(we("MetalRoughTexture",ye(o.ambientOcclusionTexture?H(o.ambientOcclusionTexture,0):Y(1),r?H(r,0):Y(1),i?H(i,0):Y(1)),o.getScene()).then(async p=>{const d=await this.exportTextureAsync(p,_);d&&(c.metallicRoughnessTexture=d)}))}}else n&&f.push(this.exportTextureAsync(n).then(h=>{h&&(c.baseColorTexture=h)})),i&&f.push(this.exportTextureAsync(i).then(h=>{h&&(c.metallicRoughnessTexture=h)}));return f.length>0&&(this._exporter._materialNeedsUVsSet.add(o),await Promise.all(f)),u}_getTextureSampler(e){const t={};if(!e||!(e instanceof v))return t;const s=this._getGLTFTextureWrapMode(e.wrapU);s!==10497&&(t.wrapS=s);const n=this._getGLTFTextureWrapMode(e.wrapV);switch(n!==10497&&(t.wrapT=n),e.samplingMode){case v.LINEAR_LINEAR:{t.magFilter=9729,t.minFilter=9729;break}case v.LINEAR_NEAREST:{t.magFilter=9729,t.minFilter=9728;break}case v.NEAREST_LINEAR:{t.magFilter=9728,t.minFilter=9729;break}case v.NEAREST_LINEAR_MIPLINEAR:{t.magFilter=9728,t.minFilter=9987;break}case v.NEAREST_NEAREST:{t.magFilter=9728,t.minFilter=9728;break}case v.NEAREST_LINEAR_MIPNEAREST:{t.magFilter=9728,t.minFilter=9985;break}case v.LINEAR_NEAREST_MIPNEAREST:{t.magFilter=9729,t.minFilter=9984;break}case v.LINEAR_NEAREST_MIPLINEAR:{t.magFilter=9729,t.minFilter=9986;break}case v.NEAREST_NEAREST_MIPLINEAR:{t.magFilter=9728,t.minFilter=9986;break}case v.LINEAR_LINEAR_MIPLINEAR:{t.magFilter=9729,t.minFilter=9987;break}case v.LINEAR_LINEAR_MIPNEAREST:{t.magFilter=9729,t.minFilter=9985;break}case v.NEAREST_NEAREST_MIPNEAREST:{t.magFilter=9728,t.minFilter=9984;break}}return t}_getGLTFTextureWrapMode(e){switch(e){case v.WRAP_ADDRESSMODE:return 10497;case v.CLAMP_ADDRESSMODE:return 33071;case v.MIRROR_ADDRESSMODE:return 33648;default:return N.Error(`Unsupported Texture Wrap Mode ${e}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(e,t,s){const n={diffuseColor:e._albedoColor,specularColor:e._reflectivityColor,glossiness:e._microSurface},i=e._albedoTexture,r=e._reflectivityTexture,o=e._useMicroSurfaceFromReflectivityMapAlpha;if(r&&!o)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((i||r)&&s){this._exporter._materialNeedsUVsSet.add(e);const c=this._exportTextureSampler(i||r),l=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(i,r,n),f=this._exporter._textures;if(l.baseColorTextureData){const u=await this._exportImageAsync(`baseColor${f.length}`,l.baseColorTextureData);t.baseColorTexture=this._exportTextureInfo(u,c,i?.coordinatesIndex)}if(l.metallicRoughnessTextureData){const u=await this._exportImageAsync(`metallicRoughness${f.length}`,l.metallicRoughnessTextureData);t.metallicRoughnessTexture=this._exportTextureInfo(u,c,r?.coordinatesIndex)}return l}else return this._convertSpecularGlossinessToMetallicRoughness(n)}async exportPBRMaterialAsync(e,t){const s={},n={name:e.name},i=e.isMetallicWorkflow();if(i){const c=e._albedoColor,l=e.alpha;c&&(s.baseColorFactor=[c.r,c.g,c.b,l])}const r=i?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(e._albedoColor,e._metallic,e._roughness,e._albedoTexture,e._metallicTexture,e._metallicTexture,e,s,t):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(e,s,t);await this._setMetallicRoughnessPbrMaterialAsync(r,e,n,s,t),await this._finishMaterialAsync(n,e);const o=this._exporter._materials;return o.push(n),o.length-1}async _setMetallicRoughnessPbrMaterialAsync(e,t,s,n,i){if(Ee(s,t),(!e.baseColor.equalsWithEpsilon(ce,L)||!_e.WithinEpsilon(t.alpha,1,L))&&(n.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,t.alpha]),e.metallic!=null&&e.metallic!==1&&(n.metallicFactor=e.metallic),e.roughness!=null&&e.roughness!==1&&(n.roughnessFactor=e.roughness),t.backFaceCulling!=null&&!t.backFaceCulling&&(t._twoSidedLighting||N.Warn(t.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),s.doubleSided=!0),i){const o=[],c=t instanceof b?t._bumpTexture:t.geometryNormalTexture;c&&o.push(this.exportTextureAsync(c).then(u=>{u&&(s.normalTexture=u,c.level!==1&&(s.normalTexture.scale=c.level))}));const l=t instanceof b?t._ambientTexture:t.ambientOcclusionTexture;l&&o.push(new Promise(async u=>{if(t instanceof le&&n.metallicRoughnessTexture){const h=this._exportTextureSampler(l),m=this._exporter._textures[n.metallicRoughnessTexture.index].source,_=this._exportTextureInfo(m,h,l.coordinatesIndex);return this._textureMap.set(l.uniqueId,_),this._exporter._extensionsPostExportTextures("exporter",_,l),u(_)}else return u(await this.exportTextureAsync(l))}).then(async u=>{if(u){const h={index:u.index,texCoord:u.texCoord,extensions:u.extensions};s.occlusionTexture=h,t instanceof b?h.strength=t._ambientTextureStrength:h.strength=t.ambientOcclusionTexture.level}}));const f=t instanceof b?t._emissiveTexture:t.emissionColorTexture;f&&o.push(this.exportTextureAsync(f).then(u=>{u&&(s.emissiveTexture=u)})),o.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(o))}const r=t instanceof b?t._emissiveColor:t.emissionColor;r.equalsWithEpsilon(Te,L)||(s.emissiveFactor=r.asArray()),s.pbrMetallicRoughness=n}async exportOpenPBRMaterialAsync(e,t){const s={},n={name:e.name},i=e.baseColor,r=e.geometryOpacity;i&&(s.baseColorFactor=[i.r,i.g,i.b,r]);const o=await this._convertMetalRoughFactorsToMetallicRoughnessAsync(e.baseColor,e.baseMetalness,e.specularRoughness,e.baseColorTexture,e.baseMetalnessTexture,e.specularRoughnessTexture,e,s,t);await this._setMetallicRoughnessPbrMaterialAsync(o,e,n,s,t),await this._finishMaterialAsync(n,e);const c=this._exporter._materials;return c.push(n),c.length-1}async exportTextureAsync(e,t=null){let s=this._textureMap.get(t??e.uniqueId);if(s)return s;const n=this._exportTextureSampler(e),i=await this._exportTextureImageAsync(e);return s=this._exportTextureInfo(i,n,e.coordinatesIndex),this._textureMap.set(t??e.uniqueId,s),this._exporter._extensionsPostExportTextures("exporter",s,e),s}async _exportTextureImageAsync(e){const t=e.mimeType??"none",s=this._internalTextureToImage,n=e.getInternalTexture().uniqueId;s[n]=s[n]||{};let i=s[n][t];return i===void 0&&(i=(async()=>{const r=await Qe(e);if(r&&(t==="none"||r.type===t))return await this._exportImageAsync(e.name,r);let o="image/png";t!=="none"&&(Oe(t)?o=t:(o="image/png",N.Warn(`Unsupported media type: ${t}. Exporting texture as PNG.`)));const c=e.getSize(),l=await Ue(e),f=await re(l,c.width,c.height,o);return await this._exportImageAsync(e.name,f)})(),s[n][t]=i),await i}async _exportImageAsync(e,t){const s=this._exporter._images;let n;if(this._exporter._shouldUseGlb){n={name:e,mimeType:t.type,bufferView:void 0};const i=await t.arrayBuffer(),r=this._exporter._bufferManager.createBufferView(new Uint8Array(i));this._exporter._bufferManager.setBufferView(n,r)}else{const i=e.replace(/\.\/|\/|\.\\|\\/g,"_"),r=be(t.type);let o=i+r;s.some(c=>c.uri===o)&&(o=`${i}_${N.RandomId()}${r}`),n={name:e,uri:o},this._exporter._imageData[o]=t}return s.push(n),s.length-1}_exportTextureInfo(e,t,s){const n=this._exporter._textures;let i=n.findIndex(o=>o.sampler==t&&o.source===e);i===-1&&(i=n.length,n.push({source:e,sampler:t}));const r={index:i};return s&&(r.texCoord=s),r}_exportTextureSampler(e){const t=this._getTextureSampler(e),s=this._exporter._samplers,n=s.findIndex(i=>i.minFilter===t.minFilter&&i.magFilter===t.magFilter&&i.wrapS===t.wrapS&&i.wrapT===t.wrapT);return n!==-1?n:(s.push(t),s.length-1)}}class Ie{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const e in this.files){const t=this.files[e],s=new Blob([t],{type:J(e)});N.Download(s,e)}}}const pe=Z.Compose(new O(-1,1,1),W.Identity(),O.Zero());function et(a,e){if(!(a instanceof ie))return!1;if(e){if(!a.getWorldMatrix().equalsWithEpsilon(Z.IdentityReadOnly,K))return!1}else if(!a.getWorldMatrix().multiplyToRef(pe,P.Matrix[0]).equalsWithEpsilon(Z.IdentityReadOnly,K))return!1;return!(a instanceof ue&&a.geometry)}const te=O.ZeroReadOnly,me=W.Identity(),ne=O.OneReadOnly,tt=new O(-1,1,1);function fe(a,e){const{byteOffset:t,byteStride:s,type:n,normalized:i}=a,r=a.getSize(),o=e.reduce((f,u)=>u.getTotalVertices()>f?u.getTotalVertices():f,-Number.MAX_VALUE),c=o*r,l=a.getKind();return{byteOffset:t,byteStride:s,componentCount:r,type:n,count:c,normalized:i,totalVertices:o,kind:l}}function st(a){switch(a){case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":return 4}}function nt(a){return a.some(e=>e>=256)}function Se(a){switch(a){case A.PositionKind:case A.NormalKind:case A.TangentKind:case A.ColorKind:case A.MatricesIndicesKind:case A.MatricesIndicesExtraKind:case A.MatricesWeightsKind:case A.MatricesWeightsExtraKind:case A.UVKind:case A.UV2Kind:case A.UV3Kind:case A.UV4Kind:case A.UV5Kind:case A.UV6Kind:return!0}return!1}function it(a,e){if(a==A.ColorKind)return e?"VEC4":"VEC3";switch(a){case A.PositionKind:case A.NormalKind:return"VEC3";case A.TangentKind:case A.MatricesIndicesKind:case A.MatricesIndicesExtraKind:case A.MatricesWeightsKind:case A.MatricesWeightsExtraKind:return"VEC4";case A.UVKind:case A.UV2Kind:case A.UV3Kind:case A.UV4Kind:case A.UV5Kind:case A.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${a}`)}function rt(a){switch(a){case A.PositionKind:return"POSITION";case A.NormalKind:return"NORMAL";case A.TangentKind:return"TANGENT";case A.ColorKind:return"COLOR_0";case A.UVKind:return"TEXCOORD_0";case A.UV2Kind:return"TEXCOORD_1";case A.UV3Kind:return"TEXCOORD_2";case A.UV4Kind:return"TEXCOORD_3";case A.UV5Kind:return"TEXCOORD_4";case A.UV6Kind:return"TEXCOORD_5";case A.MatricesIndicesKind:return"JOINTS_0";case A.MatricesIndicesExtraKind:return"JOINTS_1";case A.MatricesWeightsKind:return"WEIGHTS_0";case A.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${a}`)}function ot(a){switch(a){case k.TriangleFillMode:return 4;case k.TriangleStripDrawMode:return 5;case k.TriangleFanDrawMode:return 6;case k.PointListDrawMode:case k.PointFillMode:return 0;case k.LineLoopDrawMode:return 2;case k.LineListDrawMode:return 1;case k.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${a}`)}function at(a){switch(a){case k.TriangleFillMode:case k.TriangleStripDrawMode:case k.TriangleFanDrawMode:return!0}return!1}function Ve(a){const e=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);e>0&&(a.x/=e,a.y/=e,a.z/=e)}function de(a){return a.x*=-1,a}function ct(a){return pe.invertToRef(P.Matrix[0]).multiplyToRef(a,a).multiplyToRef(pe,a),a}function ge(a){if(a.x*a.x+a.y*a.y>.5){const e=Math.abs(a.x),t=Math.abs(a.y);if(e>t){const s=Math.sign(a.x);a.x=e,a.y*=-s,a.z*=-s,a.w*=s}else{const s=Math.sign(a.y);a.x*=-s,a.y=t,a.z*=s,a.w*=-s}}else{const e=Math.abs(a.z),t=Math.abs(a.w);if(e>t){const s=Math.sign(a.z);a.x*=-s,a.y*=s,a.z=e,a.w*=-s}else{const s=Math.sign(a.w);a.x*=s,a.y*=-s,a.z*=-s,a.w=t}}return a}function Fe(a){a.copyFromFloats(-a.z,a.w,a.x,-a.y)}function ft(a,e){const t=O.FromArrayToRef(e.translation||[0,0,0],0,P.Vector3[0]),s=W.FromArrayToRef(e.rotation||[0,0,0,1],0,P.Quaternion[0]),n=Z.ComposeToRef(ne,s,t,P.Matrix[0]),i=O.FromArrayToRef(a.translation||[0,0,0],0,P.Vector3[2]),r=W.FromArrayToRef(a.rotation||[0,0,0,1],0,P.Quaternion[1]),o=Z.ComposeToRef(ne,r,i,P.Matrix[1]);n.multiplyToRef(o,o),o.decompose(void 0,s,t),t.equalsWithEpsilon(te,K)?delete e.translation:e.translation=t.asArray(),s.equalsWithEpsilon(me,K)?delete e.rotation:e.rotation=s.asArray(),e.scale&&delete e.scale}function ht(a,e){if(!(e instanceof ie)||!(e.getChildren().length===1&&a.getChildren().length===0&&a.parent===e))return!1;const s=a.getScene(),n=a instanceof Ne&&!s.useRightHandedSystem?tt:ne;return e.scaling.equalsWithEpsilon(n,K)?!0:(Q.Warn(`Cannot collapse node ${a.name} into parent node ${e.name} with modified scaling.`),!1)}function lt(a,e,t,s){let n=a;return(e!==0||t!==a.length)&&(n=Array.isArray(a)?a.slice(e,e+t):a.subarray(e,e+t)),n instanceof Int32Array?new Uint32Array(n.buffer,n.byteOffset,n.length):Array.isArray(n)?s?new Uint32Array(n):new Uint16Array(n):n}function ut(a){if(a instanceof Array){const e=new Float32Array(a);return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}return ArrayBuffer.isView(a)?new Uint8Array(a.buffer,a.byteOffset,a.byteLength):new Uint8Array(a)}function pt(a,e,t,s){const{byteOffset:n,byteStride:i,type:r,normalized:o}=e,c=e.getSize(),l=new Array(c).fill(1/0),f=new Array(c).fill(-1/0);return ee(a,n+t*i,i,c,r,s*c,o,u=>{for(let h=0;h<c;h++)l[h]=Math.min(l[h],u[h]),f[h]=Math.max(f[h],u[h])}),{min:l,max:f}}const mt=new Map([[Int8Array,(a,e,t)=>a.setInt8(e,t)],[Uint8Array,(a,e,t)=>a.setUint8(e,t)],[Uint8ClampedArray,(a,e,t)=>a.setUint8(e,t)],[Int16Array,(a,e,t)=>a.setInt16(e,t,!0)],[Uint16Array,(a,e,t)=>a.setUint16(e,t,!0)],[Int32Array,(a,e,t)=>a.setInt32(e,t,!0)],[Uint32Array,(a,e,t)=>a.setUint32(e,t,!0)],[Float32Array,(a,e,t)=>a.setFloat32(e,t,!0)],[Float64Array,(a,e,t)=>a.setFloat64(e,t,!0)]]);class ve{writeTypedArray(e){this._checkGrowBuffer(e.byteLength);const t=mt.get(e.constructor);for(let s=0;s<e.length;s++)t(this._dataView,this._byteOffset,e[s]),this._byteOffset+=e.BYTES_PER_ELEMENT}constructor(e){this._data=new Uint8Array(e),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(e){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,e),this._byteOffset++}writeInt8(e){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,e),this._byteOffset++}writeInt16(e){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,e,!0),this._byteOffset+=2}writeUInt16(e){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,e,!0),this._byteOffset+=2}writeInt32(e){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,e,!0),this._byteOffset+=4}writeUInt32(e){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,e,!0),this._byteOffset+=4}writeFloat32(e){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,e,!0),this._byteOffset+=4}writeFloat64(e){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,e,!0),this._byteOffset+=8}_checkGrowBuffer(e){const t=this.byteOffset+e;if(t>this._data.byteLength){const s=new Uint8Array(t*2);s.set(this._data),this._data=s,this._dataView=new DataView(this._data.buffer)}}}function Re(a){return a%4===0?4:a%2===0?2:1}class dt{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(e){let t=0;this._bufferViewToData.forEach(i=>{t+=i.byteLength});const s=new ve(t),n=Array.from(this._bufferViewToData.keys()).sort((i,r)=>Re(r.byteLength)-Re(i.byteLength));for(const i of n){i.byteOffset=s.byteOffset,e.push(i);const r=e.length-1,o=this.getPropertiesWithBufferView(i);for(const c of o)c.bufferView=r;s.writeTypedArray(this._bufferViewToData.get(i)),this._bufferViewToData.delete(i)}return s.getOutputData()}createBufferView(e,t){const s={buffer:0,byteOffset:void 0,byteLength:e.byteLength,byteStride:t};return this._bufferViewToData.set(s,e),s}createAccessor(e,t,s,n,i,r,o){this._verifyBufferView(e);const c={bufferView:void 0,componentType:s,count:n,type:t,min:r?.min,max:r?.max,normalized:o,byteOffset:i};return this.setBufferView(c,e),this._accessorToBufferView.set(c,e),c}setBufferView(e,t){this._verifyBufferView(t),this.getPropertiesWithBufferView(t).push(e)}removeBufferView(e){const t=this.getPropertiesWithBufferView(e);for(const s of t)s.bufferView!==void 0&&delete s.bufferView;this._bufferViewToData.delete(e),this._bufferViewToProperties.delete(e),this._accessorToBufferView.forEach((s,n)=>{s===e&&(n.byteOffset!==void 0&&delete n.byteOffset,this._accessorToBufferView.delete(n))})}getBufferView(e){const t=this._accessorToBufferView.get(e);return this._verifyBufferView(t),t}getPropertiesWithBufferView(e){return this._verifyBufferView(e),this._bufferViewToProperties.set(e,this._bufferViewToProperties.get(e)??[]),this._bufferViewToProperties.get(e)}getData(e){return this._verifyBufferView(e),this._bufferViewToData.get(e)}_verifyBufferView(e){if(e===void 0||!this._bufferViewToData.has(e))throw new Error(`BufferView ${e} not found in BufferManager.`)}}var X;(function(a){a[a.INTANGENT=0]="INTANGENT",a[a.OUTTANGENT=1]="OUTTANGENT"})(X||(X={}));class V{static _IsTransformable(e){return e&&(e instanceof ie||e instanceof se||e instanceof De)}static _CreateNodeAnimation(e,t,s,n,i){if(this._IsTransformable(e)){const r=[],o=[],c=t.getKeys(),l=V._CalculateMinMaxKeyFrames(c),f=V._DeduceInterpolation(c,s,n),u=f.interpolationType,h=f.shouldBakeAnimation;if(h?V._CreateBakedAnimation(e,t,s,l.min,l.max,t.framePerSecond,i,r,o,l,n):u==="LINEAR"||u==="STEP"?V._CreateLinearOrStepAnimation(e,t,s,r,o,n):u==="CUBICSPLINE"?V._CreateCubicSplineAnimation(e,t,s,r,o,n):V._CreateBakedAnimation(e,t,s,l.min,l.max,t.framePerSecond,i,r,o,l,n),r.length&&o.length)return{inputs:r,outputs:o,samplerInterpolation:u,inputsMin:h?l.min:N.FloatRound(l.min/t.framePerSecond),inputsMax:h?l.max:N.FloatRound(l.max/t.framePerSecond)}}return null}static _DeduceAnimationInfo(e){let t=null,s="VEC3",n=!1;const i=e.targetProperty.split(".");switch(i[0]){case"scaling":{t="scale";break}case"position":{t="translation";break}case"rotation":{s="VEC4",t="rotation";break}case"rotationQuaternion":{s="VEC4",n=!0,t="rotation";break}case"influence":{s="SCALAR",t="weights";break}default:N.Error(`Unsupported animatable property ${i[0]}`)}return t?{animationChannelTargetPath:t,dataAccessorType:s,useQuaternion:n}:(N.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(e,t,s,n,i,r,o,c,l,f,u){let h;if(V._IsTransformable(e)&&e.animations)for(const m of e.animations){if(u&&!u(m))continue;const _=V._DeduceAnimationInfo(m);_&&(h={name:m.name,samplers:[],channels:[]},V._AddAnimation(`${m.name}`,m.hasRunningRuntimeAnimations?t:h,e,m,_.dataAccessorType,_.animationChannelTargetPath,n,r,o,c,_.useQuaternion,l,f),h.samplers.length&&h.channels.length&&s.push(h))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(e,t,s,n,i,r,o,c,l,f,u){let h;if(e instanceof We){const m=e.morphTargetManager;if(m)for(let _=0;_<m.numTargets;++_){const g=m.getTarget(_);for(const p of g.animations){if(u&&!u(p))continue;const d=new G(`${p.name}`,"influence",p.framePerSecond,p.dataType,p.loopMode,p.enableBlending),w=[],y=p.getKeys();for(let E=0;E<y.length;++E){const C=y[E];for(let S=0;S<m.numTargets;++S)S==_?w.push(C):w.push({frame:C.frame,value:0})}d.setKeys(w,!0);const x=V._DeduceAnimationInfo(d);x&&(h={name:d.name,samplers:[],channels:[]},V._AddAnimation(p.name,p.hasRunningRuntimeAnimations?t:h,e,d,x.dataAccessorType,x.animationChannelTargetPath,n,r,o,c,x.useQuaternion,l,f,m.numTargets),h.samplers.length&&h.channels.length&&s.push(h))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(e,t,s,n,i,r,o,c,l){let f;if(e.animationGroups){const u=e.animationGroups;for(const h of u){const m=new Map,_=new Map,g=new Set,p=h.to-h.from;f={name:h.name,channels:[],samplers:[]};for(let d=0;d<h.targetedAnimations.length;++d){const w=h.targetedAnimations[d],y=w.target,x=w.animation;if(l&&!l(x))continue;const E=c.has(y);if(this._IsTransformable(y)||y.length===1&&this._IsTransformable(y[0])){const C=V._DeduceAnimationInfo(w.animation);if(C){const S=this._IsTransformable(y)?y:this._IsTransformable(y[0])?y[0]:null;S&&V._AddAnimation(`${x.name}`,f,S,x,C.dataAccessorType,C.animationChannelTargetPath,s,n,i,r,C.useQuaternion,o,E)}}else if((y instanceof oe||y.length===1&&y[0]instanceof oe)&&V._DeduceAnimationInfo(w.animation)){const S=y instanceof oe?y:y[0];if(S){const I=e.morphTargetManagers.find(M=>{for(let T=0;T<M.numTargets;++T)if(M.getTarget(T)===S)return!0;return!1});if(I){const M=e.meshes.find(T=>T.morphTargetManager===I);M&&(m.has(M)||m.set(M,new Map),m.get(M)?.set(S,x),g.add(M),_.set(M,x))}}}}g.forEach(d=>{const w=d.morphTargetManager;let y=null;const x=[],C=_.get(d).getKeys(),S=C.length;for(let M=0;M<S;++M)for(let T=0;T<w.numTargets;++T){const U=w.getTarget(T),B=m.get(d);if(B){const F=B.get(U);F?(y||(y=new G(`${h.name}_${d.name}_MorphWeightAnimation`,"influence",F.framePerSecond,G.ANIMATIONTYPE_FLOAT,F.loopMode,F.enableBlending)),x.push(F.getKeys()[M])):x.push({frame:h.from+p/S*M,value:U.influence,inTangent:C[0].inTangent?0:void 0,outTangent:C[0].outTangent?0:void 0})}}y.setKeys(x,!0);const I=V._DeduceAnimationInfo(y);I&&V._AddAnimation(`${h.name}_${d.name}_MorphWeightAnimation`,f,d,y,I.dataAccessorType,I.animationChannelTargetPath,s,n,i,r,I.useQuaternion,o,!1,w?.numTargets)}),f.channels.length&&f.samplers.length&&t.push(f)}}}static _AddAnimation(e,t,s,n,i,r,o,c,l,f,u,h,m,_){const g=V._CreateNodeAnimation(s,n,r,u,h);let p,d,w,y,x,E;if(g){if(_){let q=0,D=0;const $=[];for(;g.inputs.length>0;)D=g.inputs.shift(),q%_==0&&$.push(D),q++;g.inputs=$}const C=o.get(s),S=new Float32Array(g.inputs);p=c.createBufferView(S),d=c.createAccessor(p,"SCALAR",5126,g.inputs.length,void 0,{min:[g.inputsMin],max:[g.inputsMax]}),f.push(d),w=f.length-1;const I=new W,M=new O,T=new O,U=s instanceof se,B=st(i),F=new Float32Array(g.outputs.length*B);g.outputs.forEach(function(q,D){let $=q;switch(r){case"translation":m&&(O.FromArrayToRef(q,0,T),de(T),T.toArray($));break;case"rotation":q.length===4?W.FromArrayToRef(q,0,I):($=new Array(4),O.FromArrayToRef(q,0,M),W.FromEulerVectorToRef(M,I)),m&&(ge(I),U&&Fe(I)),I.toArray($);break}F.set($,D*B)}),p=c.createBufferView(F),d=c.createAccessor(p,i,5126,g.outputs.length),f.push(d),y=f.length-1,x={interpolation:g.samplerInterpolation,input:w,output:y},t.samplers.push(x),E={sampler:t.samplers.length-1,target:{node:C,path:r}},t.channels.push(E)}}static _CreateBakedAnimation(e,t,s,n,i,r,o,c,l,f,u){let h;const m=W.Identity();let _=null,g,p=null,d=null,w=null,y=null,x=null;f.min=N.FloatRound(n/r);const E=t.getKeys();for(let C=0,S=E.length;C<S;++C){if(x=null,d=E[C],C+1<S)if(w=E[C+1],d.value.equals&&d.value.equals(w.value)||d.value===w.value)if(C===0)x=d.frame;else continue;else x=w.frame;else{if(y=E[C-1],d.value.equals&&d.value.equals(y.value)||d.value===y.value)continue;x=i}if(x)for(let I=d.frame;I<=x;I+=o){if(g=N.FloatRound(I/r),g===_)continue;_=g,p=g;const M={key:0,repeatCount:0,loopMode:t.loopMode};h=t._interpolate(I,M),V._SetInterpolatedValue(e,h,g,t,s,m,c,l,u)}}p&&(f.max=p)}static _ConvertFactorToVector3OrQuaternion(e,t,s,n,i){const r=V._GetBasePositionRotationOrScale(t,n,i),o=s.targetProperty.split("."),c=o?o[1]:"",l=i?W.FromArray(r).normalize():O.FromArray(r);switch(c){case"x":case"y":case"z":{l[c]=e;break}case"w":{l.w=e;break}default:N.Error(`glTFAnimation: Unsupported component name "${c}"!`)}return l}static _SetInterpolatedValue(e,t,s,n,i,r,o,c,l){let f;if(o.push(s),i==="weights"){c.push([t]);return}n.dataType===G.ANIMATIONTYPE_FLOAT&&(t=this._ConvertFactorToVector3OrQuaternion(t,e,n,i,l)),i==="rotation"?(l?r=t:(f=t,W.RotationYawPitchRollToRef(f.y,f.x,f.z,r)),c.push(r.asArray())):(f=t,c.push(f.asArray()))}static _CreateLinearOrStepAnimation(e,t,s,n,i,r){for(const o of t.getKeys())n.push(o.frame/t.framePerSecond),V._AddKeyframeValue(o,t,i,s,e,r)}static _CreateCubicSplineAnimation(e,t,s,n,i,r){t.getKeys().forEach(function(o){n.push(o.frame/t.framePerSecond),V._AddSplineTangent(X.INTANGENT,i,s,"CUBICSPLINE",o,r),V._AddKeyframeValue(o,t,i,s,e,r),V._AddSplineTangent(X.OUTTANGENT,i,s,"CUBICSPLINE",o,r)})}static _GetBasePositionRotationOrScale(e,t,s){let n;return t==="rotation"?s?n=(e.rotationQuaternion??W.Identity()).asArray():n=(e.rotation??O.Zero()).asArray():t==="translation"?n=(e.position??O.Zero()).asArray():n=(e.scaling??O.One()).asArray(),n}static _AddKeyframeValue(e,t,s,n,i,r){let o;const c=t.dataType;if(c===G.ANIMATIONTYPE_VECTOR3){let l=e.value.asArray();if(n==="rotation"){const f=O.FromArray(l);l=W.RotationYawPitchRoll(f.y,f.x,f.z).asArray()}s.push(l)}else if(c===G.ANIMATIONTYPE_FLOAT){if(n==="weights")s.push([e.value]);else if(o=this._ConvertFactorToVector3OrQuaternion(e.value,i,t,n,r),o){if(n==="rotation"){const l=r?o:W.RotationYawPitchRoll(o.y,o.x,o.z).normalize();s.push(l.asArray())}s.push(o.asArray())}}else c===G.ANIMATIONTYPE_QUATERNION?s.push(e.value.normalize().asArray()):N.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(e,t,s){let n,i=!1,r;if(t==="rotation"&&!s)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let o=0,c=e.length;o<c;++o)if(r=e[o],r.inTangent||r.outTangent)if(n){if(n!=="CUBICSPLINE"){n="LINEAR",i=!0;break}}else n="CUBICSPLINE";else if(n){if(n==="CUBICSPLINE"||r.interpolation&&r.interpolation===1&&n!=="STEP"){n="LINEAR",i=!0;break}}else r.interpolation&&r.interpolation===1?n="STEP":n="LINEAR";return n||(n="LINEAR"),{interpolationType:n,shouldBakeAnimation:i}}static _AddSplineTangent(e,t,s,n,i,r){let o;const c=e===X.INTANGENT?i.inTangent:i.outTangent;if(n==="CUBICSPLINE"){if(s==="rotation")if(c)if(r)o=c.asArray();else{const l=c;o=W.RotationYawPitchRoll(l.y,l.x,l.z).asArray()}else o=[0,0,0,0];else s==="weights"?c?o=[c]:o=[0]:c?o=c.asArray():o=[0,0,0];t.push(o)}}static _CalculateMinMaxKeyFrames(e){let t=1/0,s=-1/0;return e.forEach(function(n){t=Math.min(t,n.frame),s=Math.max(s,n.frame)}),{min:t,max:s}}}function gt(a,e,t,s,n,i){const r={attributes:{},influence:a.influence,name:a.name},o=e.geometry;if(!o)return N.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),r;const c=i?-1:1,l=4,f=O.Zero();let u=0,h=0;if(a.hasPositions){const m=a.getPositions(),_=o.getVerticesData(A.PositionKind);if(_){const g=new Float32Array(_.length),p=[1/0,1/0,1/0],d=[-1/0,-1/0,-1/0];h=_.length/3,u=0;for(let x=u;x<h;++x){const E=O.FromArray(_,x*3);O.FromArray(m,x*3).subtractToRef(E,f),f.x*=c,p[0]=Math.min(p[0],f.x),d[0]=Math.max(d[0],f.x),p[1]=Math.min(p[1],f.y),d[1]=Math.max(d[1],f.y),p[2]=Math.min(p[2],f.z),d[2]=Math.max(d[2],f.z),g[x*3]=f.x,g[x*3+1]=f.y,g[x*3+2]=f.z}const w=t.createBufferView(g,l*3),y=t.createAccessor(w,"VEC3",5126,m.length/3,0,{min:p,max:d});n.push(y),r.attributes.POSITION=n.length-1}else N.Warn(`Morph target positions for mesh ${e.name} were not exported. Mesh does not have position vertex data`)}if(a.hasNormals){const m=a.getNormals(),_=o.getVerticesData(A.NormalKind);if(_){const g=new Float32Array(_.length);h=_.length/3,u=0;for(let w=u;w<h;++w){const y=O.FromArray(_,w*3).normalize();O.FromArray(m,w*3).normalize().subtractToRef(y,f),g[w*3]=f.x*c,g[w*3+1]=f.y,g[w*3+2]=f.z}const p=t.createBufferView(g,l*3),d=t.createAccessor(p,"VEC3",5126,m.length/3,0);n.push(d),r.attributes.NORMAL=n.length-1}else N.Warn(`Morph target normals for mesh ${e.name} were not exported. Mesh does not have normals vertex data`)}if(a.hasTangents){const m=a.getTangents(),_=o.getVerticesData(A.TangentKind);if(_){h=_.length/4;const g=new Float32Array(h*3);u=0;for(let w=u;w<h;++w){const y=O.FromArray(_,w*4);Ve(y);const x=O.FromArray(m,w*3);Ve(x),x.subtractToRef(y,f),g[w*3]=f.x*c,g[w*3+1]=f.y,g[w*3+2]=f.z}const p=t.createBufferView(g,l*3),d=t.createAccessor(p,"VEC3",5126,h,0);n.push(d),r.attributes.TANGENT=n.length-1}else N.Warn(`Morph target tangents for mesh ${e.name} were not exported. Mesh does not have tangents vertex data`)}if(a.hasColors){const m=a.getColors(),_=o.getVerticesData(A.ColorKind),g=o.getVertexBuffer(A.ColorKind);if(_&&g){const p=g.getSize();h=_.length/p;const d=new Float32Array(h*p);u=0;for(let x=u;x<h;++x)if(p===3){const E=O.FromArray(_,x*p);O.FromArray(m,x*p).subtractToRef(E,f),d[x*3]=f.x,d[x*3+1]=f.y,d[x*3+2]=f.z}else if(p===4){const E=new ae,C=ae.FromArray(_,x*p);ae.FromArray(m,x*p).subtractToRef(C,E),d[x*4]=E.x,d[x*4+1]=E.y,d[x*4+2]=E.z,d[x*4+3]=E.w}else N.Warn(`Unsupported number of components for color attribute: ${p}`);const w=t.createBufferView(d,l*p),y=t.createAccessor(w,p===3?"VEC3":"VEC4",5126,h,0);n.push(y),r.attributes.COLOR_0=n.length-1}else N.Warn(`Morph target colors for mesh ${e.name} were not exported. Mesh does not have colors vertex data`)}return r}class he{constructor(e,t){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=e,this.wasAddedByNoopNode=t}getIndicesAccessor(e,t,s,n,i){return this._indicesAccessorMap.get(e)?.get(t)?.get(s)?.get(n)?.get(i)}setIndicesAccessor(e,t,s,n,i,r){let o=this._indicesAccessorMap.get(e);o||(o=new Map,this._indicesAccessorMap.set(e,o));let c=o.get(t);c||(c=new Map,o.set(t,c));let l=c.get(s);l||(l=new Map,c.set(s,l));let f=l.get(n);f||(f=new Map,l.set(n,f)),f.set(i,r)}pushExportedNode(e){this._exportedNodes.has(e)||this._exportedNodes.add(e)}getNodesSet(){return this._exportedNodes}getVertexBufferView(e){return this._vertexBufferViewMap.get(e)}setVertexBufferView(e,t){this._vertexBufferViewMap.set(e,t)}setRemappedBufferView(e,t,s){this._remappedBufferView.set(e,new Map),this._remappedBufferView.get(e).set(t,s)}getRemappedBufferView(e,t){return this._remappedBufferView.get(e)?.get(t)}getVertexAccessor(e,t,s){return this._vertexAccessorMap.get(e)?.get(t)?.get(s)}setVertexAccessor(e,t,s,n){let i=this._vertexAccessorMap.get(e);i||(i=new Map,this._vertexAccessorMap.set(e,i));let r=i.get(t);r||(r=new Map,i.set(t,r)),r.set(s,n)}hasVertexColorAlpha(e){return this._vertexMapColorAlpha.get(e)||!1}setHasVertexColorAlpha(e,t){return this._vertexMapColorAlpha.set(e,t)}getMesh(e){return this._meshMap.get(e)}setMesh(e,t){this._meshMap.set(e,t)}bindMorphDataToMesh(e,t){const s=this._meshMorphTargetMap.get(e)||[];this._meshMorphTargetMap.set(e,s),s.indexOf(t)===-1&&s.push(t)}getMorphTargetsFromMesh(e){return this._meshMorphTargetMap.get(e)}}class R{_ApplyExtension(e,t,s,n){if(s>=t.length)return Promise.resolve(e);const i=n(t[s],e);return i?i.then(async r=>r?await this._ApplyExtension(r,t,s+1,n):null):this._ApplyExtension(e,t,s+1,n)}_ApplyExtensions(e,t){const s=[];for(const n of R._ExtensionNames)s.push(this._extensions[n]);return this._ApplyExtension(e,s,0,t)}_extensionsPostExportNodeAsync(e,t,s,n,i){return this._ApplyExtensions(t,(r,o)=>r.postExportNodeAsync&&r.postExportNodeAsync(e,o,s,n,i,this._bufferManager))}_extensionsPostExportMaterialAsync(e,t,s){return this._ApplyExtensions(t,(n,i)=>n.postExportMaterialAsync&&n.postExportMaterialAsync(e,i,s))}async _extensionsPostExportMaterialAdditionalTexturesAsync(e,t,s){const n=[];return await Promise.all(R._ExtensionNames.map(async i=>{const r=this._extensions[i];if(r.postExportMaterialAdditionalTexturesAsync){const o=await r.postExportMaterialAdditionalTexturesAsync(e,t,s);n.push(...o)}})),n}_extensionsPostExportTextures(e,t,s){for(const n of R._ExtensionNames){const i=this._extensions[n];i.postExportTexture&&i.postExportTexture(e,t,s)}}_extensionsPostExportMeshPrimitive(e){for(const t of R._ExtensionNames){const s=this._extensions[t];s.postExportMeshPrimitive&&s.postExportMeshPrimitive(e,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const e of R._ExtensionNames){const t=this._extensions[e];t.preGenerateBinaryAsync&&await t.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(e){for(const t of R._ExtensionNames){const s=this._extensions[t];s.enabled&&e(s)}}_extensionsOnExporting(){this._forEachExtensions(e=>{var t,s,n;e.wasUsed&&((t=this._glTF).extensionsUsed||(t.extensionsUsed=[]),this._glTF.extensionsUsed.indexOf(e.name)===-1&&this._glTF.extensionsUsed.push(e.name),e.required&&((s=this._glTF).extensionsRequired||(s.extensionsRequired=[]),this._glTF.extensionsRequired.indexOf(e.name)===-1&&this._glTF.extensionsRequired.push(e.name)),(n=this._glTF).extensions||(n.extensions={}),e.onExporting&&e.onExporting())})}_loadExtensions(){for(const e of R._ExtensionNames){const t=R._ExtensionFactories[e](this);this._extensions[e]=t}}constructor(e=Le.LastCreatedScene,t){if(this._glTF={asset:{generator:`Babylon.js v${Ke.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new Je(this),this._extensions={},this._bufferManager=new dt,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!e)throw new Error("No scene available to export");this._babylonScene=e,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:s=>s?.gltf?.extras,animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...t},this._loadExtensions()}dispose(){for(const e in this._extensions)this._extensions[e].dispose()}get options(){return this._options}static RegisterExtension(e,t,s=100){R.UnregisterExtension(e)&&N.Warn(`Extension with the name ${e} already exists`),R._ExtensionFactories[e]=t;const n=s??0;R._ExtensionOrders[e]=n;let i=R._ExtensionNames.length;for(let r=0;r<R._ExtensionNames.length;r++){const o=R._ExtensionNames[r],c=R._ExtensionOrders[o];if(n<c){i=r;break}}R._ExtensionNames.splice(i,0,e)}static UnregisterExtension(e){if(!R._ExtensionFactories[e])return!1;delete R._ExtensionFactories[e],delete R._ExtensionOrders[e];const t=R._ExtensionNames.indexOf(e);return t!==-1&&R._ExtensionNames.splice(t,1),!0}_generateJSON(e,t,s){const n={byteLength:e};return n.byteLength&&(this._glTF.buffers=[n]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.scene=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(n.uri=t+".bin"),s?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(e){const t=await this._generateBinaryAsync();this._extensionsOnExporting();const s=this._generateJSON(t.byteLength,e,!0),n=new Blob([t],{type:"application/octet-stream"}),i=e+".gltf",r=e+".bin",o=new Ie;if(o.files[i]=s,o.files[r]=n,this._imageData)for(const c in this._imageData)o.files[c]=this._imageData[c];return o}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(e){const t=e%4;return t===0?t:4-t}async generateGLBAsync(e){this._shouldUseGlb=!0;const t=await this._generateBinaryAsync();this._extensionsOnExporting();const s=this._generateJSON(t.byteLength),n=e+".glb",i=12,r=8;let o=s.length,c;typeof TextEncoder<"u"&&(c=new TextEncoder().encode(s),o=c.length);const l=this._getPadding(o),f=this._getPadding(t.byteLength),u=i+2*r+o+l+t.byteLength+f,h=new ve(u);if(h.writeUInt32(1179937895),h.writeUInt32(2),h.writeUInt32(u),h.writeUInt32(o+l),h.writeUInt32(1313821514),c)h.writeTypedArray(c);else for(let g=0;g<o;++g){const p=s.charCodeAt(g);p!=s.codePointAt(g)?h.writeUInt8(95):h.writeUInt8(p)}for(let _=0;_<l;++_)h.writeUInt8(32);h.writeUInt32(t.byteLength+f),h.writeUInt32(5130562),h.writeTypedArray(t);for(let _=0;_<f;++_)h.writeUInt8(0);const m=new Ie;return m.files[n]=new Blob([h.getOutputData()],{type:"application/octet-stream"}),m}_setNodeTransformation(e,t,s){if(t.getPivotPoint().equalsWithEpsilon(te,K)||N.Warn("Pivot points are not supported in the glTF serializer"),!t.position.equalsWithEpsilon(te,K)){const i=P.Vector3[0].copyFrom(t.position);s&&de(i),e.translation=i.asArray()}t.scaling.equalsWithEpsilon(ne,K)||(e.scale=t.scaling.asArray());const n=t.rotationQuaternion?.clone()||W.FromEulerAngles(t.rotation.x,t.rotation.y,t.rotation.z);n.equalsWithEpsilon(me,K)||(s&&ge(n),e.rotation=n.normalize().asArray())}_setCameraTransformation(e,t,s){const n=P.Vector3[0],i=P.Quaternion[0],r=t.getWorldMatrix();if(t.parent){const o=t.parent.getWorldMatrix().invertToRef(P.Matrix[0]);r.multiplyToRef(o,P.Matrix[1]).decompose(void 0,i,n)}else r.decompose(void 0,i,n);n.equalsWithEpsilon(te,K)||(s&&de(n),e.translation=n.asArray()),s&&ge(i),this._babylonScene.useRightHandedSystem||Fe(i),i.equalsWithEpsilon(me,K)||(e.rotation=i.asArray())}_listAvailableCameras(){for(const e of this._babylonScene.cameras){const t={type:e.mode===se.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(e.name&&(t.name=e.name),t.type==="perspective")t.perspective={aspectRatio:e.getEngine().getAspectRatio(e),yfov:e.fovMode===se.FOVMODE_VERTICAL_FIXED?e.fov:e.fov*e.getEngine().getAspectRatio(e),znear:e.minZ,zfar:e.maxZ};else if(t.type==="orthographic"){const s=e.orthoLeft&&e.orthoRight?.5*(e.orthoRight-e.orthoLeft):e.getEngine().getRenderWidth()*.5,n=e.orthoBottom&&e.orthoTop?.5*(e.orthoTop-e.orthoBottom):e.getEngine().getRenderHeight()*.5;t.orthographic={xmag:s,ymag:n,znear:e.minZ,zfar:e.maxZ}}this._camerasMap.set(e,t)}}_exportAndAssignCameras(){const e=Array.from(this._camerasMap.values());for(const t of e){const s=this._nodesCameraMap.get(t);if(s!==void 0){this._cameras.push(t);for(const n of s)n.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const e of this._babylonScene.skeletons){if(e.bones.length<=0)continue;const t={joints:[]};this._skinMap.set(e,t)}}_exportAndAssignSkeletons(e){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const s=this._skinMap.get(t);if(s==null)continue;const n={};let i=-1;for(let c=0;c<t.bones.length;++c){const l=t.bones[c],f=l.getIndex()??c;f!==-1&&(n[f]=l,f>i&&(i=f))}const r=[];for(let c=0;c<=i;++c){const l=n[c],f=l.getTransformNode(),u=f?this._nodeMap.get(f):void 0;if(u===void 0){N.Warn("Exporting a bone without a linked transform node is currently unsupported.");continue}s.joints.push(u);const h=l.getAbsoluteInverseBindMatrix().clone();e.has(f)&&ct(h),r.push(h)}const o=this._nodesSkinMap.get(s);if(s.joints.length>0&&o!==void 0){const c=new Float32Array(r.length*16);r.forEach((u,h)=>{c.set(u.m,h*16)});const l=this._bufferManager.createBufferView(c);this._accessors.push(this._bufferManager.createAccessor(l,"MAT4",5126,r.length)),s.inverseBindMatrices=this._accessors.length-1,this._skins.push(s);const f=this._skins.length-1;for(const u of o)u.skin=f}}}async _exportSceneAsync(){const e={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(e.extras=c)}const t=new Array,s=new Array,n=new Array;for(const c of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&et(c,this._babylonScene.useRightHandedSystem)?n.push(...c.getChildren()):this._babylonScene.useRightHandedSystem?t.push(c):s.push(c);this._listAvailableCameras(),this._listAvailableSkeletons();const i=new he(!0,!1);e.nodes.push(...await this._exportNodesAsync(s,i));const r=new he(!1,!1);e.nodes.push(...await this._exportNodesAsync(t,r));const o=new he(!1,!0);e.nodes.push(...await this._exportNodesAsync(n,o)),e.nodes.length&&this._scenes.push(e),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(i.getNodesSet()),this._babylonScene.animationGroups.length&&V._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(e){let t=this._shouldExportNodeMap.get(e);return t===void 0&&(t=this._options.shouldExportNode(e),this._shouldExportNodeMap.set(e,t)),t}async _exportNodesAsync(e,t){const s=new Array;this._exportBuffers(e,t);for(const n of e)await this._exportNodeAsync(n,s,t);return s}_collectBuffers(e,t,s,n,i){if(this._shouldExportNode(e)&&e instanceof ue&&e.geometry){const r=e.geometry.getVertexBuffers();if(r)for(const c in r){if(!Se(c))continue;const l=r[c];i.setHasVertexColorAlpha(l,e.hasVertexAlpha);const f=l._buffer,u=t.get(f)||[];t.set(f,u),u.indexOf(l)===-1&&u.push(l);const h=s.get(l)||[];s.set(l,h),h.indexOf(e)===-1&&h.push(e)}const o=e.morphTargetManager;if(o)for(let c=0;c<o.numTargets;c++){const l=o.getTarget(c),f=n.get(l)||[];n.set(l,f),f.indexOf(e)===-1&&f.push(e)}}for(const r of e.getChildren())this._collectBuffers(r,t,s,n,i)}_exportBuffers(e,t){const s=new Map,n=new Map,i=new Map;for(const c of e)this._collectBuffers(c,s,n,i,t);const r=Array.from(s.keys());for(const c of r){const l=c.getData();if(!l)throw new Error("Buffer data is not available");const f=s.get(c);if(!f)continue;const u=f[0].byteStride;if(f.some(p=>p.byteStride!==u))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const h=ut(l).slice();for(const p of f){const d=n.get(p),{byteOffset:w,byteStride:y,componentCount:x,type:E,count:C,normalized:S,kind:I}=fe(p,d);switch(I){case A.NormalKind:case A.TangentKind:{ee(h,w,y,x,E,C,S,M=>{const T=Math.sqrt(M[0]*M[0]+M[1]*M[1]+M[2]*M[2]);if(T>0){const U=1/T;M[0]*=U,M[1]*=U,M[2]*=U}});break}case A.ColorKind:{const M=d.filter(F=>F.material instanceof Ae||F.material==null).length;if(M==0)break;if(M!=d.length){Q.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}E==A.UNSIGNED_BYTE&&Q.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const T=new z,U=new Pe,B=this._babylonScene.getEngine().useExactSrgbConversions;ee(h,w,y,x,E,C,S,F=>{F.length===3?(T.fromArray(F,0),T.toLinearSpaceToRef(T,B),T.toArray(F,0)):(U.fromArray(F,0),U.toLinearSpaceToRef(U,B),U.toArray(F,0))})}}}if(t.convertToRightHanded){for(const p of f){const d=n.get(p),{byteOffset:w,byteStride:y,componentCount:x,type:E,count:C,normalized:S,kind:I}=fe(p,d);switch(I){case A.PositionKind:case A.NormalKind:case A.TangentKind:ee(h,w,y,x,E,C,S,M=>{M[0]=-M[0]})}}t.convertedToRightHandedBuffers.set(c,h)}const m=this._bufferManager.createBufferView(h,u);t.setVertexBufferView(c,m);const _=new Map;for(const p of f){const d=n.get(p),{kind:w,totalVertices:y}=fe(p,d);switch(w){case A.MatricesIndicesKind:case A.MatricesIndicesExtraKind:if(p.type==A.FLOAT){const x=p.getFloatData(y);x!==null&&_.set(p,x)}}}_.size!==0&&Q.Warn("Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const g=Array.from(_.keys());for(const p of g){const d=_.get(p);if(!d)continue;const w=nt(d),y=new(w?Uint16Array:Uint8Array)(d.length);for(let E=0;E<d.length;E++)y[E]=d[E];const x=this._bufferManager.createBufferView(y,4*(w?2:1));t.setRemappedBufferView(c,p,x)}}const o=Array.from(i.keys());for(const c of o){const l=i.get(c);if(!l)continue;const f=gt(c,l[0],this._bufferManager,this._bufferViews,this._accessors,t.convertToRightHanded);for(const u of l)t.bindMorphDataToMesh(u,f)}}async _exportNodeAsync(e,t,s){let n=this._nodeMap.get(e);if(n!==void 0){t.includes(n)||t.push(n);return}const i=await this._createNodeAsync(e,s);if(i){n=this._nodes.length,this._nodes.push(i),this._nodeMap.set(e,n),s.pushExportedNode(e),t.push(n);const o={name:"runtime animations",channels:[],samplers:[]},c=[];this._babylonScene.animationGroups.length||(V._CreateMorphTargetAnimationFromMorphTargetAnimations(e,o,c,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,s.convertToRightHanded,this._options.shouldExportAnimation),e.animations.length&&V._CreateNodeAnimationFromNodeAnimations(e,o,c,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,s.convertToRightHanded,this._options.shouldExportAnimation)),o.channels.length&&o.samplers.length&&this._animations.push(o),c.forEach(l=>{l.channels.length&&l.samplers.length&&this._animations.push(l)})}const r=i?[]:t;for(const o of e.getChildren())await this._exportNodeAsync(o,r,s);i&&r.length&&(i.children=r)}async _createNodeAsync(e,t){if(!this._shouldExportNode(e))return null;const s={};if(e.name&&(s.name=e.name),e.metadata){const i=this._options.metadataSelector(e.metadata);i&&(s.extras=i)}if(e instanceof ie&&(this._setNodeTransformation(s,e,t.convertToRightHanded),e instanceof ue)){const i=e instanceof ze?e.sourceMesh:e;if(i.subMeshes&&i.subMeshes.length>0&&(s.mesh=await this._exportMeshAsync(i,t)),e.skeleton){const r=this._skinMap.get(e.skeleton);r!==void 0&&(this._nodesSkinMap.get(r)===void 0&&this._nodesSkinMap.set(r,[]),this._nodesSkinMap.get(r)?.push(s))}}if(e instanceof Ne){const i=this._camerasMap.get(e);if(i){this._nodesCameraMap.get(i)===void 0&&this._nodesCameraMap.set(i,[]),this._setCameraTransformation(s,e,t.convertToRightHanded);const r=e.parent;if(r!==null&&ht(e,r)){const o=this._nodeMap.get(r);if(o!==void 0){const c=this._nodes[o];return ft(s,c),this._nodesCameraMap.get(i)?.push(c),null}}this._nodesCameraMap.get(i)?.push(s)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",s,e,this._nodeMap,t.convertToRightHanded)?s:(Q.Warn(`Not exporting node ${e.name}`),null)}_exportIndices(e,t,s,n,i,r,o,c,l){let f=null;l.mode=ot(r);const u=o!==k.CounterClockWiseSideOrientation&&at(r);if(u){if(r===k.TriangleStripDrawMode||r===k.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");const h=t?new Uint32Array(n):new Uint16Array(n);if(e)for(let m=0;m+2<n;m+=3)h[m]=e[s+m]+i,h[m+1]=e[s+m+2]+i,h[m+2]=e[s+m+1]+i;else for(let m=0;m+2<n;m+=3)h[m]=m,h[m+1]=m+2,h[m+2]=m+1;f=h}else if(e&&i!==0){const h=t?new Uint32Array(n):new Uint16Array(n);for(let m=0;m<n;m++)h[m]=e[s+m]+i;f=h}else e&&(f=lt(e,s,n,t));if(f){let h=c.getIndicesAccessor(e,s,n,i,u);if(h===void 0){const m=this._bufferManager.createBufferView(f),_=t?5125:5123;this._accessors.push(this._bufferManager.createAccessor(m,"SCALAR",_,n,0)),h=this._accessors.length-1,c.setIndicesAccessor(e,s,n,i,u,h)}l.indices=h}}_exportVertexBuffer(e,t,s,n,i,r){const o=e.getKind();if(!Se(o)||o.startsWith("uv")&&!this._options.exportUnusedUVs&&(!t||!this._materialNeedsUVsSet.has(t)))return;let c=i.getVertexAccessor(e,s,n);if(c===void 0){const l=i.convertedToRightHandedBuffers.get(e._buffer)||e._buffer.getData(),f=o===A.PositionKind?pt(l,e,s,n):void 0,u=(o===A.MatricesIndicesKind||o===A.MatricesIndicesExtraKind)&&e.type===A.FLOAT,h=u?A.UNSIGNED_BYTE:e.type,m=u?void 0:e.normalized,_=u?i.getRemappedBufferView(e._buffer,e):i.getVertexBufferView(e._buffer),g=e.byteOffset+s*e.byteStride;this._accessors.push(this._bufferManager.createAccessor(_,it(o,i.hasVertexColorAlpha(e)),h,n,g,f,m)),c=this._accessors.length-1,i.setVertexAccessor(e,s,n,c)}r.attributes[rt(o)]=c}async _exportMaterialAsync(e,t,s,n){let i=this._materialMap.get(e);if(i===void 0){const r=t&&Object.keys(t).some(o=>o.startsWith("uv"));if(e=e instanceof qe?e.subMaterials[s.materialIndex]:e,e instanceof b)i=await this._materialExporter.exportPBRMaterialAsync(e,r);else if(e instanceof Ae)i=await this._materialExporter.exportStandardMaterialAsync(e,r);else if(e instanceof le)i=await this._materialExporter.exportOpenPBRMaterialAsync(e,r);else{Q.Warn(`Unsupported material '${e.name}' with type ${e.getClassName()}`);return}this._materialMap.set(e,i)}n.material=i}async _exportMeshAsync(e,t){let s=t.getMesh(e);if(s!==void 0)return s;const n={primitives:[]};s=this._meshes.length,this._meshes.push(n),t.setMesh(e,s);const i=e.isUnIndexed?null:e.getIndices(),r=e.geometry?.getVertexBuffers(),o=t.getMorphTargetsFromMesh(e),c=e instanceof Ge,l=e instanceof He,f=e.subMeshes;if(r&&f&&f.length>0)for(const u of f){const h={attributes:{}},m=u.getMaterial()||this._babylonScene.defaultMaterial;if(l){const p={name:m.name},d=e,w=z.White(),y=d.material?.alpha??1,x=d.greasedLineMaterial?.color??w;(!x.equalsWithEpsilon(w,K)||y<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...x.asArray(),y]}),this._materials.push(p),h.material=this._materials.length-1}else if(c){const p={name:m.name},d=e;(!d.color.equalsWithEpsilon(z.White(),K)||d.alpha<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...d.color.asArray(),d.alpha]}),this._materials.push(p),h.material=this._materials.length-1}else await this._exportMaterialAsync(m,r,u,h);const _=c||l?k.LineListDrawMode:e.overrideRenderingFillMode??m.fillMode;let g=m._getEffectiveOrientation(e);t.wasAddedByNoopNode&&!e.getScene().useRightHandedSystem&&(g=g===k.ClockWiseSideOrientation?k.CounterClockWiseSideOrientation:k.ClockWiseSideOrientation),this._exportIndices(i,i?$e(i,u.indexCount,u.indexStart,u.verticesStart):u.verticesCount>65535,i?u.indexStart:u.verticesStart,i?u.indexCount:u.verticesCount,-u.verticesStart,_,g,t,h);for(const p of Object.values(r))this._exportVertexBuffer(p,m,u.verticesStart,u.verticesCount,t,h);if(o){h.targets=[];for(const p of o)h.targets.push(p.attributes)}n.primitives.push(h),this._extensionsPostExportMeshPrimitive(h)}if(o){n.weights=[],n.extras||(n.extras={}),n.extras.targetNames=[];for(const u of o)n.weights.push(u.influence),n.extras.targetNames.push(u.name)}return s}}R._ExtensionNames=new Array;R._ExtensionFactories={};R._ExtensionOrders={};class At{static async GLTFAsync(e,t,s){(!s||!s.exportWithoutWaitingForScene)&&await e.whenReadyAsync();const n=new R(e,s),i=await n.generateGLTFAsync(t.replace(/\.[^/.]+$/,""));return n.dispose(),i}static async GLBAsync(e,t,s){(!s||!s.exportWithoutWaitingForScene)&&await e.whenReadyAsync();const n=new R(e,s),i=await n.generateGLBAsync(t.replace(/\.[^/.]+$/,""));return n.dispose(),i}}export{At as GLTF2Export};
