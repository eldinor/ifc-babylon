import{qj as p}from"./index-Ds31uFJL.js";function O(t){return t.split(" ").filter(i=>i!=="").map(i=>parseFloat(i))}function x(t,i,o){for(;o.length!==i;){const n=O(t.lines[t.index++]);o.push(...n)}}function V(t,i,o){let n=0,e=0,r=0,u=0,f=0,g=0;for(let s=0;s<t.numberOfHorizontalAngles-1;s++)if(o<t.horizontalAngles[s+1]||s===t.numberOfHorizontalAngles-2){e=s,r=t.horizontalAngles[s],u=t.horizontalAngles[s+1];break}for(let s=0;s<t.numberOfVerticalAngles-1;s++)if(i<t.verticalAngles[s+1]||s===t.numberOfVerticalAngles-2){n=s,f=t.verticalAngles[s],g=t.verticalAngles[s+1];break}const c=u-r,b=g-f;if(b===0)return 0;const h=c===0?0:(o-r)/c,A=(i-f)/b,d=c===0?e:e+1,l=p(t.candelaValues[e][n],t.candelaValues[d][n],h),a=p(t.candelaValues[e][n+1],t.candelaValues[d][n+1],h);return p(l,a,A)}function z(t){const n={lines:new TextDecoder("utf-8").decode(t).split(`
`),index:0},e={version:n.lines[0],candelaValues:[],horizontalAngles:[],verticalAngles:[],numberOfHorizontalAngles:0,numberOfVerticalAngles:0};for(n.index=1;n.lines.length>0&&!n.lines[n.index].includes("TILT=");)n.index++;n.lines[n.index].includes("INCLUDE"),n.index++;const r=O(n.lines[n.index++]);e.numberOfLights=r[0],e.lumensPerLamp=r[1],e.candelaMultiplier=r[2],e.numberOfVerticalAngles=r[3],e.numberOfHorizontalAngles=r[4],e.photometricType=r[5],e.unitsType=r[6],e.width=r[7],e.length=r[8],e.height=r[9];const u=O(n.lines[n.index++]);e.ballastFactor=u[0],e.fileGenerationType=u[1],e.inputWatts=u[2];for(let l=0;l<e.numberOfHorizontalAngles;l++)e.candelaValues[l]=[];x(n,e.numberOfVerticalAngles,e.verticalAngles),x(n,e.numberOfHorizontalAngles,e.horizontalAngles);for(let l=0;l<e.numberOfHorizontalAngles;l++)x(n,e.numberOfVerticalAngles,e.candelaValues[l]);let f=-1;for(let l=0;l<e.numberOfHorizontalAngles;l++)for(let a=0;a<e.numberOfVerticalAngles;a++)e.candelaValues[l][a]*=e.candelaValues[l][a]*e.candelaMultiplier*e.ballastFactor*e.fileGenerationType,f=Math.max(f,e.candelaValues[l][a]);if(f>0)for(let l=0;l<e.numberOfHorizontalAngles;l++)for(let a=0;a<e.numberOfVerticalAngles;a++)e.candelaValues[l][a]/=f;const g=180,c=g*2,b=c*g,h=new Float32Array(c*g),A=e.horizontalAngles[0],d=e.horizontalAngles[e.numberOfHorizontalAngles-1];for(let l=0;l<b;l++){let a=l%c;const m=Math.floor(l/c);d-A!==0&&(a<A||a>=d)&&(a%=d*2,a>d&&(a=d*2-a)),h[m+a*g]=V(e,m,a)}return{width:c/2,height:1,data:h}}class T{constructor(){this.supportCascades=!1}loadCubeData(){throw".ies not supported in Cube."}loadData(i,o,n){const e=new Uint8Array(i.buffer,i.byteOffset,i.byteLength),r=z(e);n(r.width,r.height,!!o.useMipMaps,!1,()=>{const u=o.getEngine();o.type=1,o.format=6,o._gammaSpace=!1,u._uploadDataToTextureDirectly(o,r.data)})}}const v=Object.freeze(Object.defineProperty({__proto__:null,_IESTextureLoader:T},Symbol.toStringTag,{value:"Module"}));export{z as L,T as _,v as i};
